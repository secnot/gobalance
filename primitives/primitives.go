package primitives


import (
	"strconv"
	"bytes"
	"fmt"

	"github.com/btcsuite/btcd/chaincfg/chainhash"
	"github.com/btcsuite/btcd/chaincfg"
	"github.com/btcsuite/btcd/txscript"
)

const (
	// defaultTransactionAlloc is the default size used for the backing array
	// for transactions.  The transaction array will dynamically grow as needed, but
	// this figure is intended to provide enough space for the number of
	// transactions in the vast majority of blocks without needing to grow the
	// backing array multiple times.
	defaultTransactionAlloc = 2048

	// defaultTxInOutAlloc is the default size used for the backing array for
	// transaction inputs and outputs.  The array will dynamically grow as needed,
	// but this figure is intended to provide enough space for the number of
	// inputs and outputs in a typical transaction without needing to grow the
	// backing array multiple times.
	defaultTxInOutAlloc = 15

	// Position for bitcoin value decimal point
	bitcoinValueDecimalPoint = 8
)

// Hash for the first block in the blockchain
var MainNetGenesisHash = chainhash.Hash([chainhash.HashSize]byte{
		0x6f, 0xe2, 0x8c, 0x0a, 0xb6, 0xf1, 0xb3, 0x72,
		0xc1, 0xa6, 0xa2, 0x46, 0xae, 0x63, 0xf7, 0x4f,
		0x93, 0x1e, 0x83, 0x65, 0xe1, 0x5a, 0x08, 0x9c,
		0x68, 0xd6, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00,
})

// Empty hash 
var ZeroHash = chainhash.Hash([chainhash.HashSize]byte{
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
})


// Operate on the TestNet Bitcoin network
var DefaultChainParams = &chaincfg.MainNetParams

// Select chain operationOperate on MainNet network
// &chaincfg.MainNetParams
// &chaincfg.TestNet3Params
func SelectChain(chain *chaincfg.Params) {
	DefaultChainParams = chain 
}



type Block struct {
	Hash         chainhash.Hash 
	PrevHash     chainhash.Hash
	Height       uint64

	Transactions []*Tx
}

type Tx struct {
	Hash *chainhash.Hash // Transaction hash
	In   []*TxOut        // Inputs substituted by the TxOut they point to
	Out  []*TxOut        // Outputs
}

type TxOut struct {
	TxHash *chainhash.Hash // Hash for the transaction containing the TxOut
	Nout   uint32          // Output number
	Addr   string          // Bitcoin address from pkScript
	Value  int64           // Output ammount
}

func NewBlock(hash chainhash.Hash, prev chainhash.Hash, height uint64) *Block {
	return &Block{
		Hash:         hash,
		PrevHash:     prev,
		Height:       height,
	}
}

func (b *Block) AddTx(tx *Tx) {
	if b.Transactions == nil {
		b.Transactions = make([]*Tx, 0, defaultTransactionAlloc)
	}
	b.Transactions = append(b.Transactions, tx)
}


func NewTx(hash *chainhash.Hash) *Tx {
	return &Tx{
		Hash: hash,
		In:   make([]*TxOut, 0, defaultTxInOutAlloc),
		Out:  make([]*TxOut, 0, defaultTxInOutAlloc),
	}
}

// Add Input to transaction
func (t *Tx) AddIn(in *TxOut) {
	t.In = append(t.In, in)
}

// Add Output to transaction
func (t *Tx) AddOut(out *TxOut) {
	t.Out = append(t.Out, out)
}

// forEachAddress calls a function once for each address in the transaction
// with the balance delta generated by the transaction for that address
func (t *Tx) ForEachAddress(do func(addr string, balance int64, tx *Tx)) {

	// Balance modifications by the 
	balance := make(map[string]int64, len(t.In)+len(t.Out))

	// Find all addresese
	for _, out := range t.Out {
		if out.Addr == "" {
			continue
		}
		balance[out.Addr] += out.Value
	}

	for _, in := range t.In {
		if in.Addr == "" {
			continue
		}
		balance[in.Addr] -= in.Value
	}

	// call function for each address in the transaction
	for addr, bal := range balance {
		do(addr, bal, t)
	}
}



func NewTxOut(txHash *chainhash.Hash, nout uint32, address string, value int64) *TxOut {
	return &TxOut{
		TxHash: txHash,
		Nout:   nout,
		Addr:   address,
		Value:  value,
	}
}

// PkScriptToAddr extracts the bitcoin address from a wire.TxOut.PkScript
func PkScriptToAddr(pkScript []byte) string {
	// See http://godoc.org/github.com/btcsuite/btcd/txscript#example-ExtractPkScriptAddrs
	scriptClass, addresses, _, err := txscript.ExtractPkScriptAddrs(pkScript, 
		DefaultChainParams)
	if err != nil || len(addresses) == 0 {
		return ""
	}

	switch scriptClass {
	case txscript.PubKeyHashTy:
		return addresses[0].EncodeAddress()
	case txscript.PubKeyTy:
		return addresses[0].EncodeAddress()
	case txscript.ScriptHashTy:
		return addresses[0].EncodeAddress()
	// Remaining cases to default no address
	// case txscript.NonStandardTy:
	// case txscript.MultiSigTy:
	// case txscript.NullDataTy:
	default:
		return ""
	}
}

func (t TxOut) String() string {
	return fmt.Sprintf("<TxOut %v(%d) | %sB | %s>", 
		*t.TxHash, 
		t.Nout, 
		BitcoinValueToString(t.Value),
		t.Addr)
}

func (t Tx) String() string {
	return fmt.Sprintf("<Tx: %v>", *t.Hash)
}

func (b Block) String() string {
	return fmt.Sprintf("<Block: %v (%d)>", b.Hash, b.Height)
}
	
// DetailString returns a more detailed string representations of a Tx
func (t Tx) DetailString() string {
	var buf bytes.Buffer

	buf.WriteString(fmt.Sprint(t))
	buf.WriteString("\n")

	// Inputs
	for _, in := range t.In {
		buf.WriteString(fmt.Sprintf("In\t %v\n", in))
	}

	// Outputs
	for _, out := range t.Out {
		buf.WriteString(fmt.Sprintf("Out\t %v\n", out))
	}
	return buf.String()
}

// DetailString returns a more detailed string representations of a Block
func (b Block) DetailString() string {
	var buf bytes.Buffer

	buf.WriteString(fmt.Sprint(b))
	buf.WriteString("\n")

	// Transactions
	for _, tx := range b.Transactions {
		buf.WriteString(fmt.Sprintf("\t %v\n", tx))
	}

	return buf.String()
}


// Abs returns the absolute value of an integer
func abs(n int64) int64 {
	if n < 0 {
		return -n
	}
	return n
}

// Max of 2 numbers
func max(n1 int64, n2 int64) int64 {
	if n1 >= n2 {
		return n1
	}
	return n2
}

// BitcoinValueToString returns the string representation of a bitcoin value
func BitcoinValueToString(value int64) string {

	var buffer bytes.Buffer
	if value < 0 {
		buffer.WriteString("-")
	}

	str := strconv.FormatInt(abs(value), 10)
	if len(str) <= bitcoinValueDecimalPoint {
		// For less than one bitcoin need to prepend zeroes
		buffer.WriteString("0.")
		for i := 0; i < bitcoinValueDecimalPoint - len(str); i++ {
			buffer.WriteString("0")
		}
		for _, runeV := range str {
			buffer.WriteRune(runeV)
		}
	} else {
		// For more than one bitcoin just add the decimal point
		for index, runeV := range str {
			if len(str) - index == bitcoinValueDecimalPoint {
				buffer.WriteString(".")
			}
			buffer.WriteRune(runeV)
		}
	}

	return buffer.String()
}
